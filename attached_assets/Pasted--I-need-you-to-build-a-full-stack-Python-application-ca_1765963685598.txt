
I need you to build a full-stack Python application called "Chameleon: The AI-Powered API Honeypot".

1. Project Overview

This application acts as a fake vulnerable server. It accepts traffic to any URL path (e.g., /api/users, /v1/admin/login). Instead of returning 404 errors, it uses Google Gemini 1.5 Flash to Hallucinate (generate) realistic JSON responses in real-time. It then logs the attacker's details for analysis.

2. Tech Stack & Requirements

Backend: Python 3.11+, Flask.

Database: SQLite (using SQLAlchemy ORM).

AI Integration: google-generativeai library.

Frontend: HTML5, Bootstrap 5 (Dark Mode/Cybersecurity theme), JavaScript (Fetch API for auto-updates).

3. File Structure

Please organize the project exactly like this:

app.py (Main entry point)

models.py (Database schema)

ai_engine.py (Logic for calling Gemini API)

templates/dashboard.html (The admin UI)

static/style.css (Custom CSS)

requirements.txt

4. Detailed Feature Specifications

A. Database (models.py)

Create a model AttackLog with fields:

id (Integer, Primary Key)

timestamp (DateTime, default=now)

ip_address (String)

request_method (String: GET, POST, PUT, DELETE)

endpoint (String: e.g., "/admin/login")

payload_data (Text: Body of the request, if any)

ai_response_sent (Text: What Gemini generated)

user_agent (String)

B. The AI Logic (ai_engine.py)

Function: generate_honeypot_response(method, endpoint, payload)

Prompt Engineering:

System Instruction: "You are a backend server for a legacy financial corporation. You must generate a realistic JSON response for the following request. If the user sends a POST, generate a 'success' or 'validation error' response. If GET, return realistic dummy data. OUTPUT ONLY RAW JSON. NO MARKDOWN. NO CODE BLOCKS."

Error Handling: If Gemini fails or times out, return a hardcoded fallback JSON: {"error": "Internal Server Error", "code": 500}.

Cleaning: Ensure the output is stripped of "json" and "" before returning.

C. The Flask App (app.py)

Route 1: / (Redirect to dashboard for now).

Route 2: /monitor (The Dashboard). render dashboard.html.

Route 3: /api/logs (Internal API). Returns the latest 50 logs as JSON for the frontend to fetch.

Route 4: The "Catch-All" Trap. Use @app.route('/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE']).

This route must catch everything else.

Log the request to SQLite.

Call generate_honeypot_response.

Return the AI's JSON with status 200.

D. The Dashboard (dashboard.html)

Use a "Hacker/Cyber" aesthetic: Black background, neon green text (#00ff00), monospace fonts.

Table: Show columns [Time, IP, Method, Endpoint, AI Response Preview].

Auto-Refresh: Use JavaScript setInterval to fetch /api/logs every 2 seconds and update the table without reloading the page.

Stats Cards: Top of page showing "Total Attacks Captured" and "Most Attacked Endpoint".

5. Configuration

Use os.environ.get("GEMINI_API_KEY").

Ensure app.run(host='0.0.0.0', port=8080) for Replit compatibility.

Instructions:

Write the complete code for all files. Ensure the database initializes automatically if it doesn't exist.